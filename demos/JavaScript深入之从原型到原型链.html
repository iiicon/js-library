<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <script>
    
    // 首先创建一个构造函数
    function Person() {

    }
    var person = new Person()
    person.name = 'zhangsan'
    console.log(person.name)

    // 每一个函数都有一个prototype属性
    Person.prototype.name = 'lisi'
    var person2 = new Person()
    console.log(person.name, person2.name)

    // __proto__
    console.log(person.__proto__ === Person.prototype)

    // constructor
    console.log(Person === Person.prototype.constructor)

    // 顺便学一下es5获取对象的原型
    console.log(Object.getPrototypeOf(person) === Person.prototype)

    // 原型与继承就不赘述了，会一直向上查找，一直找到Object为止
    
    // 原型链就涉及到顶层的Object()

    //  Object.prototype 的原型是null null表示空对象，没有值，所以Object.prototype.__proto__ 指向null和Object.prototype没有原型是一个意思 
    console.log('Object prototype is ' + Object.prototype.__proto__)

    // 需要注意的点 
    // --constructor是在原型对象中才有的，person中的知识继承
    console.log(person.constructor === Person.prototype.constructor)

    // --__proto__虽然大部分浏览器都支持，但是在原型中并没有，它存在于Object.prototype中，可以把他理解成一个getter，当使用person.__proto__时，就是返回了一个 Object.getPrototypeOf(obj)

    // --最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：
    // 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。



  </script>
</body>
</html>